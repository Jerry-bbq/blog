# 作用域与闭包

## 一、作用域（Scope）

### 1.1 什么是作用域？

**作用域**（Scope）决定了变量、函数和对象在代码中的**可访问性**（可见性）。它规定了在哪些代码区域中可以访问特定的标识符。

- 作用域是在**代码编写时**（词法阶段）就确定的，属于**静态结构**。
- JavaScript 中的作用域主要分为：
  - **全局作用域**
  - **函数作用域**（ES5 及以前）
  - **块级作用域**（ES6 引入，通过 `let` / `const` 实现）

> ✅ 注意：在 ES6 之前，JavaScript **没有块级作用域**（`if`、`for` 等代码块不形成独立作用域），只有全局作用域和函数作用域。

### 1.2 全局作用域 vs 函数作用域

```js
var globalVar = 'I am global';

function func() {
  var localVar = 'I am local';
  console.log(globalVar); // ✅ 可访问
}
func();
console.log(localVar); // ❌ ReferenceError: localVar is not defined
```

- **函数作用域**：函数内部声明的变量仅在该函数内可见。
- **全局作用域**：在最外层定义的变量，在整个程序中都可访问。

> ⚠️ 在浏览器非严格模式下，使用 `var` 声明的全局变量会自动挂载到 `window` 对象上；而 `let` / `const` 不会。


### 1.3 块级作用域（ES6+）

ES6 引入 `let` 和 `const`，支持**块级作用域**（Block Scope）：

```js
{
  let blockVar = 1;
  const blockConst = 2;
}
console.log(blockVar); // ❌ ReferenceError
```

- `{}`（如 `if`、`for`、`while` 等）内部使用 `let`/`const` 声明的变量，只在该块内有效。
- 这解决了 `var` 在循环中常见的“意外捕获”问题（见闭包应用部分）。


### 1.4 变量提升与暂时性死区（TDZ）

| 声明方式 | 是否提升 | 初始化值 | TDZ |
|--------|--------|--------|-----|
| `var`   | ✅ 是    | `undefined` | ❌ 无 |
| `let`   | ✅ 声明提升 | ❌ 未初始化 | ✅ 有 |
| `const` | ✅ 声明提升 | ❌ 未初始化 | ✅ 有 |

```js
console.log(a); // undefined
var a = 1;

console.log(b); // ❌ ReferenceError (TDZ)
let b = 2;
```

> 💡 **函数提升优先于变量提升**：函数声明会被完整提升到作用域顶部，而变量仅提升声明。


## 二、作用域链（Scope Chain）

### 2.1 什么是作用域链？

当 JavaScript 引擎查找一个变量时，会按照以下顺序进行：

1. 当前作用域中查找；
2. 若未找到，则向上一级（父级）作用域查找；
3. 重复此过程，直到全局作用域；
4. 若仍未找到，则抛出 `ReferenceError`。

这个**由当前作用域逐级向上链接到全局作用域的链条**，称为**作用域链**。

```js
var x = 10;
function outer() {
  var y = 20;
  function inner() {
    var z = 30;
    console.log(x + y + z); // 60 → x 来自全局，y 来自 outer，z 来自 inner
  }
  inner();
}
outer();
```

### 2.2 自由变量（Free Variable）

- **定义**：在当前作用域中**未声明但被引用**的变量，称为自由变量。
- 自由变量的值通过**作用域链**向上查找。

```js
function outer() {
  let msg = "Hello";
  return function inner() {
    console.log(msg); // msg 是 inner 的自由变量
  };
}
```

> 🔍 `msg` 在 `inner` 中未声明，但被使用 → 是自由变量 → 引擎沿作用域链找到 `outer` 中的 `msg`。


### 2.3 作用域链 vs 原型链

| 特性 | 作用域链 | 原型链 |
|------|--------|--------|
| 用途 | 查找**变量标识符**（如 `x`） | 查找**对象属性**（如 `obj.name`） |
| 查找失败结果 | 抛出 `ReferenceError` | 返回 `undefined` |
| 确定时机 | 代码定义时（静态） | 对象创建/修改时（动态） |


## 三、执行上下文（Execution Context）

> ⚠️ **作用域 ≠ 执行上下文**

- **作用域**：由代码结构决定，**定义时确定**，**不会改变**。
- **执行上下文**：函数调用时创建，**运行时生成**，每次调用都不同。

### 执行过程分两个阶段：

#### 1. 解释（编译）阶段
- 词法分析、语法分析
- 确定作用域规则
- 变量/函数提升

#### 2. 执行阶段
- 创建执行上下文（包含变量对象、作用域链、this）
- 逐行执行代码
- 垃圾回收（GC）

> ✅ 同一个函数被调用多次 → 多个执行上下文，但共享同一个词法作用域。


## 四、闭包（Closure）

### 4.1 什么是闭包？

> **闭包是指：一个函数能够访问并记住其词法作用域，即使该函数在其词法作用域之外执行。**

更具体地说：
- 内部函数引用了外部函数的变量；
- 外部函数执行完毕后，这些变量**未被销毁**；
- 内部函数仍能访问它们 → 形成闭包。

```js
function outer() {
  let count = 0;
  return function inner() {
    count++;
    console.log(count);
  };
}
const counter = outer();
counter(); // 1
counter(); // 2 → count 保留在内存中
```

> ✅ 闭包的本质 = **函数 + 其词法环境的引用**

> ❗ 闭包**不一定需要 `return`**，只要内部函数在外部函数执行结束后仍能访问其变量即可（如事件监听器、`setTimeout` 回调等）。


### 4.2 闭包的原理

- 在函数执行的**预编译阶段**，若发现内部函数引用了外部变量，JavaScript 引擎会为该内部函数创建一个**闭包对象**（保存对外部词法环境的引用）。
- 外部函数执行完毕后，其执行上下文通常会被销毁，但由于闭包仍持有对其词法环境的引用，相关变量**不会被垃圾回收**。
- 只有当闭包本身被销毁（如设为 `null` 或超出作用域），这些变量才会被释放。


### 4.3 闭包的优点

1. **封装私有变量**：避免污染全局作用域。
2. **持久化状态**：变量长期驻留内存，可用于计数器、缓存等。
3. **模块化开发**：实现类似“类”的私有成员。

```js
// 模块模式（Module Pattern）
const Counter = (function () {
  let privateCount = 0; // 私有变量
  return {
    increment() { privateCount++; },
    getCount() { return privateCount; }
  };
})();
```


### 4.4 闭包的缺点

1. **内存占用**：闭包会延长变量生命周期，增加内存消耗。
2. **性能影响**：作用域链越长，变量查找越慢。
3. **意外捕获值**：在循环中使用 `var` 易导致所有闭包共享同一变量。

> ⚠️ **闭包本身不会导致内存泄漏**，但**不当使用**（如未解除引用）可能造成内存堆积。

> ✅ 建议：不再需要闭包时，将其引用设为 `null`，帮助 GC 回收。


### 4.5 闭包的经典应用场景

#### 应用 1：解决循环中的变量捕获问题

**问题（使用 `var`）**：
```js
for (var i = 1; i <= 5; i++) {
  setTimeout(() => console.log(i), 100); // 输出 6, 6, 6, 6, 6
}
```
> 原因：`i` 是全局变量，循环结束时 `i = 6`，所有回调共享同一个 `i`。

**解决方案**：

✅ 方案一：IIFE（立即执行函数）创建闭包
```js
for (var i = 1; i <= 5; i++) {
  (function(j) {
    setTimeout(() => console.log(j), 100);
  })(i);
}
```

✅ 方案二：`setTimeout` 传参（利用参数绑定）
```js
for (var i = 1; i <= 5; i++) {
  setTimeout((j) => console.log(j), 100, i);
}
```

✅ 方案三：使用 `let`（推荐）
```js
for (let i = 1; i <= 5; i++) {
  setTimeout(() => console.log(i), 100); // 输出 1, 2, 3, 4, 5
}
```
> 原理：`let` 在每次循环迭代中创建**新的块级作用域**，每个 `i` 都是独立绑定。


## 五、总结对比表

| 概念 | 说明 |
|------|------|
| **作用域** | 代码结构决定的变量可见性范围（静态） |
| **作用域链** | 变量查找路径，从当前作用域逐级向上 |
| **执行上下文** | 函数调用时创建的运行环境（动态） |
| **闭包** | 函数 + 对其词法环境的引用，使外部变量持久化 |
| **自由变量** | 在当前作用域未声明但被引用的变量 |


## 六、常见面试题（附简答）

1. **什么是闭包？**
   > 闭包是一个函数与其词法环境的组合，使得该函数即使在外部作用域执行，也能访问其定义时的变量。

2. **闭包会导致内存泄漏吗？**
   > 不会直接导致，但若大量闭包持有无用变量且不释放，可能造成内存占用过高。

3. **`var`、`let`、`const` 的作用域区别？**
   > `var`：函数作用域；`let`/`const`：块级作用域。

4. **为什么 `for (var i...)` 中的 `setTimeout` 输出相同值？**
   > 因为 `var` 声明的 `i` 是全局变量，所有回调共享同一个 `i`，循环结束时 `i=6`。

5. **如何实现私有变量？**
   > 利用闭包封装变量，仅通过返回的函数访问（模块模式）。


> 📌 **提示**：理解闭包的关键不是“函数嵌套”，而是“**函数能否在其词法作用域外访问外部变量**”。