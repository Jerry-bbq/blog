import{_ as t,c as e,o as s,V as a}from"./chunks/framework.jq6gLv6S.js";const i="/blog/assets/reactive2.qTLzcZuV.png",r="/blog/assets/reactive.nLa0lfLF.png",u=JSON.parse('{"title":"响应式原理","description":"","frontmatter":{},"headers":[],"relativePath":"advanced/framework/vue/v2/reactive.md","filePath":"advanced/framework/vue/v2/reactive.md","lastUpdated":1707813350000}'),h={name:"advanced/framework/vue/v2/reactive.md"},d=a(`<h1 id="响应式原理" tabindex="-1">响应式原理 <a class="header-anchor" href="#响应式原理" aria-label="Permalink to &quot;响应式原理&quot;">​</a></h1><p><a href="https://juejin.cn/post/6844903858850758670" target="_blank" rel="noreferrer">参考</a></p><p>简单概述：</p><p>采用<strong>数据劫持</strong>结合<strong>发布-订阅模式</strong>,通过 <code>Object.defineProperty</code> 来劫持各个属性的<code>getter</code>和<code>setter</code>,在数据变动时发布消息给<strong>订阅者</strong>,触发相应的<strong>监听回调</strong></p><p>详细描述：</p><p>当创建 Vue 实例时,会遍历 <code>data 选项</code>的属性,利用 <code>Object.defineProperty</code> 为属性添加 <code>getter</code> 和 <code>setter</code> 对数据的读取进行劫持（<code>getter</code> 用来<strong>依赖收集</strong>,<code>setter</code> 用来<strong>派发更新</strong>）,并且在内部追踪依赖,在属性被访问和修改时通知变化。</p><p>每个组件实例会有相应的 <code>watcher</code> 实例,会在组件渲染的过程中记录依赖的所有数据属性（进行依赖收集,还有 <code>computed watcher</code>,<code>user watcher</code> 实例）,之后依赖项被改动时,<code>setter</code> 方法会通知依赖与此 data 的 watcher 实例重新计算（派发更新）,从而使它关联的组件重新渲染。</p><p>实现响应式有三个核心类：</p><table><thead><tr><th>类名</th><th>作用</th></tr></thead><tbody><tr><td>Observe</td><td>数据的<code>观察者</code></td></tr><tr><td>Watcher</td><td>数据的<code>订阅者</code>，数据变化会通知Watcher，然后由Watcher进行相应的操作，例如更新视图</td></tr><tr><td>Dep</td><td>Observe和Watcher的<code>纽带</code>，当数据发生变化时，会被Observe观察到，然后由Dep通知到Watcher</td></tr></tbody></table><h2 id="观察者——observe类" tabindex="-1">观察者——Observe类 <a class="header-anchor" href="#观察者——observe类" aria-label="Permalink to &quot;观察者——Observe类&quot;">​</a></h2><p>概述：</p><p>使用<a href="./component/defineProperty.html">Object.defineProperty</a>给对象的属性添加 <code>getter</code> 和 <code>setter</code>，用于<strong>依赖收集</strong>和<strong>派发更新</strong></p><p><a href="./component/Observer.html">Observe对象实现</a>关键步骤：</p><ol><li>实例化Dep</li><li>调用<a href="./component/def.html">def()</a>把自身实例添加到数据对象 <code>value</code> 的 <code>__ob__</code> 属性上</li><li>属性如果是对象，则遍历对象属性调用<a href="./component/defineReactive.html">defineReactive()</a>；如果数组，则遍历数组调用<a href="./component/observe.html">observe()</a></li></ol><p><a href="./component/my-observe.html">Observe的简单实现</a></p><h2 id="纽带——dep类" tabindex="-1">纽带——Dep类 <a class="header-anchor" href="#纽带——dep类" aria-label="Permalink to &quot;纽带——Dep类&quot;">​</a></h2><ul><li>用于收集当前响应式对象的依赖关系</li><li>每个响应式对象包括子对象都拥有一个 Dep 实例（里面 subs 是 Watcher 实例数组</li><li>当数据有变更时,会通过 dep.notify()通知各个 watcher（Dep 实际上就是对 Watcher 的一种管理）</li></ul><p><a href="./dep/dep.html">Dep类</a>主要是定义了一些属性和方法：</p><table><thead><tr><th>属性和方法</th><th>说明</th></tr></thead><tbody><tr><td>addSub</td><td></td></tr><tr><td>removeSub</td><td></td></tr><tr><td>depend</td><td>添加依赖（实际上是调用Watcher的<code>addDep()</code>）</td></tr><tr><td>notify</td><td>派发更新（通知订阅者）（实际上是调用Wathcer的<code>update()</code>方法）</td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title">说明</p><p>Dep是Watcher实例的管理者。Dep 是一个类，用于依赖收集和派发更新，也就是存放<code>Watcher实例</code>和触发Watcher实例上的<code>update</code></p></div><h2 id="订阅者——watcher类" tabindex="-1">订阅者——Watcher类 <a class="header-anchor" href="#订阅者——watcher类" aria-label="Permalink to &quot;订阅者——Watcher类&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (options) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.deep </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">options.deep</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">options.user</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.computed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">options.computed</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.sync </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">options.sync</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.deep </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.computed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.sync </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>观察者对象 , 实例分为如下四种：</p><table><thead><tr><th>watcher</th><th>说明</th></tr></thead><tbody><tr><td>deep watcher</td><td>对对象、数组进行深度的依赖收集</td></tr><tr><td>user watcher</td><td>Vue的一般watcher</td></tr><tr><td>computed watcher</td><td>计算属性的watcher</td></tr><tr><td>sync watcher</td><td>不把更新watcher放到nextTick队列 而是立即执行更新</td></tr></tbody></table><p><a href="./watcher/watcher.html">Watcher</a>的关键步骤：</p><ul><li>get</li><li>addDep：依赖收集</li><li>update：派发更新，触发组件重新渲染</li></ul><h2 id="三者关系图" tabindex="-1">三者关系图 <a class="header-anchor" href="#三者关系图" aria-label="Permalink to &quot;三者关系图&quot;">​</a></h2><p>来源于<a href="https://segmentfault.com/a/1190000016208088" target="_blank" rel="noreferrer">segmentfault</a><img src="`+i+'" alt=""></p><p>来源于<a href="https://ustbhuangyi.github.io/vue-analysis/v2/reactive/summary.html" target="_blank" rel="noreferrer">ustbhuangyi</a><img src="'+r+'" alt=""></p>',29),n=[d];function p(l,o,c,k,g,E){return s(),e("div",null,n)}const b=t(h,[["render",p]]);export{u as __pageData,b as default};
