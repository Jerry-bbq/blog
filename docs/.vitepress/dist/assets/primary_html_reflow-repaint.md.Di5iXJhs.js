import{_ as e,c as l,o as i,a5 as a}from"./chunks/framework.FI019Rde.js";const _=JSON.parse('{"title":"浏览器的回流与重绘","description":"","frontmatter":{},"headers":[],"relativePath":"primary/html/reflow-repaint.md","filePath":"primary/html/reflow-repaint.md","lastUpdated":1707833604000}'),o={name:"primary/html/reflow-repaint.md"},t=a('<h1 id="浏览器的回流与重绘" tabindex="-1">浏览器的回流与重绘 <a class="header-anchor" href="#浏览器的回流与重绘" aria-label="Permalink to &quot;浏览器的回流与重绘&quot;">​</a></h1><h2 id="回流-reflow" tabindex="-1">回流（Reflow） <a class="header-anchor" href="#回流-reflow" aria-label="Permalink to &quot;回流（Reflow）&quot;">​</a></h2><p>当渲染树<code>Render Tree</code>中<strong>部分或全部元素的尺寸、结构、或某些属性发生改变</strong>时，浏览器重新渲染部分或全部文档的过程称为回流</p><h2 id="重绘-repaint" tabindex="-1">重绘（Repaint） <a class="header-anchor" href="#重绘-repaint" aria-label="Permalink to &quot;重绘（Repaint）&quot;">​</a></h2><p>当页面中<strong>元素样式的改变并不影响它在文档流中的位置</strong>时（例如：<code>color</code>、<code>background-color</code>、<code>visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><div class="danger custom-block"><p class="custom-block-title">🔥</p><p><strong>回流必将引起重绘</strong>，重绘不一定会引起回流</p></div><h2 id="可能导致回流的操作" tabindex="-1">可能导致回流的操作 <a class="header-anchor" href="#可能导致回流的操作" aria-label="Permalink to &quot;可能导致回流的操作&quot;">​</a></h2><ul><li>页面首次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>DOM元素的增加、删除</li><li>激活CSS伪类（例如：:hover）</li><li>查询某些属性或调用某些方法</li></ul><p>一些常用且会导致回流的属性和方法：</p><ul><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>scrollIntoView()、scrollIntoViewIfNeeded()</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li><li>scrollTo()</li></ul><h2 id="如何避免浏览器的回流" tabindex="-1">如何避免浏览器的回流 <a class="header-anchor" href="#如何避免浏览器的回流" aria-label="Permalink to &quot;如何避免浏览器的回流&quot;">​</a></h2><h3 id="_1-css层面" tabindex="-1">1. CSS层面 <a class="header-anchor" href="#_1-css层面" aria-label="Permalink to &quot;1. CSS层面&quot;">​</a></h3><ul><li>避免使用<code>table布局</code></li><li>尽可能在DOM树的最末端改变class</li><li>避免设置多层内联样式</li><li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上</li><li>避免使用CSS表达式（例如：<code>calc()</code>）</li></ul><h3 id="_2-js层面" tabindex="-1">2. JS层面 <a class="header-anchor" href="#_2-js层面" aria-label="Permalink to &quot;2. JS层面&quot;">​</a></h3><ul><li>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为class并一次性更改class属性</li><li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中</li><li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘</li><li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流</li></ul>',15),r=[t];function c(s,d,n,h,p,f){return i(),l("div",null,r)}const m=e(o,[["render",c]]);export{_ as __pageData,m as default};
