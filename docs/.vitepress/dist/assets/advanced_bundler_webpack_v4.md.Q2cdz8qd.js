import{_ as e,c as a,o as l,V as t}from"./chunks/framework.jq6gLv6S.js";const k=JSON.parse('{"title":"Webpack4","description":"","frontmatter":{},"headers":[],"relativePath":"advanced/bundler/webpack/v4.md","filePath":"advanced/bundler/webpack/v4.md","lastUpdated":1707813350000}'),i={name:"advanced/bundler/webpack/v4.md"},o=t(`<h1 id="webpack4" tabindex="-1">Webpack4 <a class="header-anchor" href="#webpack4" aria-label="Permalink to &quot;Webpack4&quot;">​</a></h1><h2 id="webpack与grunt、gulp的不同" tabindex="-1">webpack与grunt、gulp的不同 <a class="header-anchor" href="#webpack与grunt、gulp的不同" aria-label="Permalink to &quot;webpack与grunt、gulp的不同&quot;">​</a></h2><ol><li>三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。</li><li>grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。</li><li>webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。</li><li>从构建思路来说，gulp和grunt需要开发者将整个前端构建过程拆分成多个<code>Task</code>，并合理控制所有<code>Task</code>的调用关系 webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工</li></ol><h2 id="webpack怎么优化" tabindex="-1">webpack怎么优化 <a class="header-anchor" href="#webpack怎么优化" aria-label="Permalink to &quot;webpack怎么优化&quot;">​</a></h2><ul><li>多入口情况下，使用CommonsChunkPlugin来提取公共代码</li><li>通过externals配置来提取常用库</li><li>利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。</li><li>使用Happypack 实现多线程加速编译</li><li>使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度</li><li>使用Tree-shaking和Scope Hoisting来剔除多余代码</li></ul><h2 id="常见的loader及作用" tabindex="-1">常见的Loader及作用 <a class="header-anchor" href="#常见的loader及作用" aria-label="Permalink to &quot;常见的Loader及作用&quot;">​</a></h2><table><thead><tr><th>loader</th><th>说明</th></tr></thead><tbody><tr><td>babel-loader</td><td>把 ES6 转换成 ES5</td></tr><tr><td>css-loader</td><td>加载 CSS，支持模块化、压缩、文件导入等特性</td></tr><tr><td>style-loader</td><td>把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</td></tr><tr><td>file-loader</td><td>把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</td></tr><tr><td>url-loader</td><td>和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</td></tr><tr><td>source-map-loader</td><td>加载额外的 Source Map 文件，以方便断点调试</td></tr><tr><td>image-loader</td><td>加载并且压缩图片文件</td></tr><tr><td>eslint-loader</td><td>通过 ESLint 检查 JavaScript 代码</td></tr></tbody></table><h2 id="常见的plugin及作用" tabindex="-1">常见的Plugin及作用 <a class="header-anchor" href="#常见的plugin及作用" aria-label="Permalink to &quot;常见的Plugin及作用&quot;">​</a></h2><h3 id="html-webpack-plugin" tabindex="-1">html-webpack-plugin <a class="header-anchor" href="#html-webpack-plugin" aria-label="Permalink to &quot;html-webpack-plugin&quot;">​</a></h3><p>在内存中生成html 页面的插件;并加上<code>&lt;script src=&quot;bundle.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code></p><h3 id="webpack-defineplugin" tabindex="-1">webpack.DefinePlugin <a class="header-anchor" href="#webpack-defineplugin" aria-label="Permalink to &quot;webpack.DefinePlugin&quot;">​</a></h3><p>在打包过程中<code>定义全局变量</code>(定义环境变量)，主要用于告诉业务代码当前环境，是生产环境还得开发环境。之后就可以针对不同环境进行不同操作，比如生产环境要压缩，开发环境不需要压缩</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> webpack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DefinePlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;process.env&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: env</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h3 id="uglifyjs-webpack-plugin" tabindex="-1">uglifyjs-webpack-plugin <a class="header-anchor" href="#uglifyjs-webpack-plugin" aria-label="Permalink to &quot;uglifyjs-webpack-plugin&quot;">​</a></h3><p>通过UglifyES压缩ES6代码</p><h3 id="commons-chunk-plugin" tabindex="-1">commons-chunk-plugin <a class="header-anchor" href="#commons-chunk-plugin" aria-label="Permalink to &quot;commons-chunk-plugin&quot;">​</a></h3><p>提取公共代码</p><h2 id="loader和plugin的区别" tabindex="-1">Loader和Plugin的区别 <a class="header-anchor" href="#loader和plugin的区别" aria-label="Permalink to &quot;Loader和Plugin的区别&quot;">​</a></h2><p>由于 webpack 本身只能打包commonjs规范的js文件，所以，针对css，图片等格式的文件没法打包，就需要引入第三方的模块进行打包。</p><h3 id="功能不同" tabindex="-1">功能不同 <a class="header-anchor" href="#功能不同" aria-label="Permalink to &quot;功能不同&quot;">​</a></h3><p>Loader：加载器，作用是为了<strong>转化文件</strong>，完成压缩打包，比如</p><ul><li>css-loader和style-loader模块是为了打包css的</li><li>babel-loader和babel-core模块时为了把ES6的代码转成ES5</li><li>url-loader和file-loader是把图片进行打包的</li></ul><p>Plugin: 插件，作用于webpack本身上的。而且plugin不仅只局限在打包，资源的加载上，它的功能要更加丰富。从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle</p><h3 id="运行时机不同" tabindex="-1">运行时机不同 <a class="header-anchor" href="#运行时机不同" aria-label="Permalink to &quot;运行时机不同&quot;">​</a></h3><ol><li>loader运行在打包文件之前（loader为在模块加载时的预处理文件）</li><li>plugins在整个编译周期都起作用</li></ol><h2 id="是否写过loader和plugin" tabindex="-1">是否写过Loader和Plugin <a class="header-anchor" href="#是否写过loader和plugin" aria-label="Permalink to &quot;是否写过Loader和Plugin&quot;">​</a></h2><h2 id="webpack的生命周期" tabindex="-1">webpack的生命周期 <a class="header-anchor" href="#webpack的生命周期" aria-label="Permalink to &quot;webpack的生命周期&quot;">​</a></h2><p>webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全？</p><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ol><li><strong>初始化参数</strong>：从配置文件和 <code>Shell</code> 语句中读取与合并参数，得出最终的参数；</li><li><strong>开始编译</strong>：用上一步得到的参数初始化 <code>Compiler</code> 对象，加载所有配置的插件，执行对象的 <code>run</code> 方法开始执行编译；</li><li><strong>确定入口</strong>：根据配置中的 <code>entry</code> 找出所有的入口文件；</li><li><strong>编译模块</strong>：从入口文件出发，调用所有配置的 <code>Loader</code> 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li><li><strong>完成模块编译</strong>：在经过第4步使用 <code>Loader</code> 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li><li><strong>输出资源</strong>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li><li><strong>输出完成</strong>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ol><p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><h2 id="webpack的热更新是如何做到的" tabindex="-1">webpack的热更新是如何做到的 <a class="header-anchor" href="#webpack的热更新是如何做到的" aria-label="Permalink to &quot;webpack的热更新是如何做到的&quot;">​</a></h2><p>热更新（Hot Module Replacement，简称HMR）无需完全刷新整个页面的同时，更新模块</p><p>WDS (webpack-dev-server插件)的模块热替换</p><ol><li>使用<code>weback.HotModuleReplacementPlugin</code>,会生成两个补丁文件：</li></ol><ul><li>上一次编译生成的<code>hash.hot-update.json</code>,说明上次编译到现在哪些代码块发生改变</li><li>chunk名字，上一次编译生成的<code>hash.hot-update.js</code>，存放着此次代码块最新的模块定义，里面会用<code>webpackHotUpdate</code>方法</li></ul><ol start="2"><li><p>向代码快中注入HMR runtime代码，热更新的主要逻辑，比如拉取拉取代码，执行代码，执行<code>accept</code>回调都是它注入的到chunk中的</p></li><li><p><code>hotCreateRequire</code>会帮助我们给模块module的<code>parents</code>，<code>children</code>赋值</p></li></ol><h2 id="module-chunk-bundle分别什么意思-有何区别" tabindex="-1">module chunk bundle分别什么意思，有何区别 <a class="header-anchor" href="#module-chunk-bundle分别什么意思-有何区别" aria-label="Permalink to &quot;module chunk bundle分别什么意思，有何区别&quot;">​</a></h2><ul><li>module - 各源码文件</li><li>chunk - 多模块的合并成的，如entry、import()、splitChunk</li><li>bundle - 最终的输出文件</li></ul><h2 id="webpack如何实现懒加载" tabindex="-1">webpack如何实现懒加载 <a class="header-anchor" href="#webpack如何实现懒加载" aria-label="Permalink to &quot;webpack如何实现懒加载&quot;">​</a></h2><h2 id="webpack常见的性能优化" tabindex="-1">webpack常见的性能优化 <a class="header-anchor" href="#webpack常见的性能优化" aria-label="Permalink to &quot;webpack常见的性能优化&quot;">​</a></h2><h2 id="如何提高webpack的构建速度" tabindex="-1">如何提高webpack的构建速度 <a class="header-anchor" href="#如何提高webpack的构建速度" aria-label="Permalink to &quot;如何提高webpack的构建速度&quot;">​</a></h2><h2 id="babel-runtime和babel-polyfill的区别" tabindex="-1">babel-runtime和babel-polyfill的区别 <a class="header-anchor" href="#babel-runtime和babel-polyfill的区别" aria-label="Permalink to &quot;babel-runtime和babel-polyfill的区别&quot;">​</a></h2><h2 id="webpack基本配置" tabindex="-1">webpack基本配置 <a class="header-anchor" href="#webpack基本配置" aria-label="Permalink to &quot;webpack基本配置&quot;">​</a></h2><p><a href="https://www.cnblogs.com/gaoht/p/11310365.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/gaoht/p/11310365.html</a></p>`,45),r=[o];function n(d,c,p,s,h,u){return l(),a("div",null,r)}const g=e(i,[["render",n]]);export{k as __pageData,g as default};
