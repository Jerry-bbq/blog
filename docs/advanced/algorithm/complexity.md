
# 时间复杂度和空间复杂度

## 复杂度分析

复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半了。

- 数据结构和算法解决是 “如何让计算机更快时间、更省空间的解决问题”。
- 因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。
- 分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。
- 复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。

- 和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。
- 掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。

## 大O表示法

```bash
T(n) = O(f(n))
```

所有代码的执行时间 `T(n)` 与每行代码的执行次数 `n` 成正比。

- T(n)：代码执行的时间
- n：数据规模
- f(n)：每行代码执行的次数总和
- O：表示 T(n) 与 f(n) 成正比

## 时间复杂度

`大 O 时间复杂度表示法` 实际上并不具体表示代码真正的执行时间，而是表示 `代码执行时间随数据规模增长的变化趋势`，所以也叫 `渐进时间复杂度`，简称 `时间复杂度`（asymptotic time complexity）。

### 如何分析

- 只关注循环执行次数最多的一段代码

```js
// 单段代码看高频：比如循环。
function cal(n) { 
   let sum = 0;
   let i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
}
// 执行次数最多的是 for 循环及里面的代码，执行了 n 次，所以时间复杂度为 O(n)。
```

- 加法法则：总复杂度等于量级最大的那段代码的复杂度

```js
// 多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
function cal(n) {
   let sum_1 = 0;
   let p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }

   let sum_2 = 0;
   let q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   let sum_3 = 0;
   let i = 1;
   let j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
}

// 第一部分，求 sum_1 ，明确知道执行了 100 次，而和 n 的规模无关，是个常量的执行时间，不能反映增长变化趋势，所以时间复杂度为 O(1)。

// 第二和第三部分，求 sum_2 和 sum_3 ，时间复杂度是和 n 的规模有关的，为别为 O(n) 和 O(n²)。

// 所以，取三段代码的最大量级，上面例子的最终的时间复杂度为 O(n平方)。

// 同理类推，如果有 3 层 for 循环，那么时间复杂度为 O(n³)，4 层就是 O(n^4)。

// 所以，总的时间复杂度就等于量级最大的那段代码的时间复杂度。

```

- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

```js
// 嵌套代码求乘积：比如递归、多重循环等。
function cal(n) {
   let ret = 0; 
   let i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i); // 重点为  f(i)
   } 
} 
 
function f(n) {
  let sum = 0;
  let i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum;
}
// 方法 cal 循环里面调用 f 方法，而 f 方法里面也有循环。

// 所以，整个 cal() 函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n²) 。

```
- 多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加

```js
function cal(m, n) {
  let sum_1 = 0;
  let i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  let sum_2 = 0;
  let j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
// 以上代码也是求和 ，求 sum_1 的数据规模为 m、求 sum_2 的数据规模为 n，所以时间复杂度为 O(m+n)。

// 公式：T1(m) + T2(n) = O(f(m) + g(n)) 
```

- 多个规模求乘法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相乘

```js
function cal(m, n) {
  let sum_3 = 0;
   let i = 1;
   let j = 1;
   for (; i <= m; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
}

// 以上代码也是求和，两层 for 循环 ，求 sum_3 的数据规模为 m 和 n，所以时间复杂度为 O(m*n)

// 公式：T1(m) * T2(n) = O(f(m) * g(n))
```

- 多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长

```js
let i=1;
while (i <= n)  {
   i = i * 2;
}
// 代码是从 1 开始，每次循环就乘以 2，当大于 n 时，循环结束。
// 在对数阶时间复杂度的表示方法里，我们忽略对数的 “底”，统一表示为 O(logn)。
```

### 常量阶 O(1)

```js
function aFun() {
    console.log("Hello, World!");      //  需要执行 1 次
    return 0;                          //  需要执行 1 次
}
```

这个方法需要执行 2 次运算，时间复杂度为 T(n) = O(1)

### 线性阶 O(n)

```js
function bFun(n) {
    for(let i = 0; i < n; i++) {           // 需要执行 (n + 1) 次
        console.log("Hello, World!");      // 需要执行 n 次
    }
    return 0;                              // 需要执行 1 次
}
```

这个方法需要执行 ( n + 1 + n + 1 ) = 2n +2 次运算，时间复杂度为 T(n) = O(n)

### 平方阶 O(n²)

```js
function cal(n) {
   let sum = 0;                   // 1 次
   let i = 1;                     // 1 次
   let j = 1;                     // 1 次
   for (; i <= n; ++i) {          // n 次
     j = 1;                       // n 次
     for (; j <= n; ++j) {        // n * n ，也即是  n平方次
       sum = sum +  i * j;        // n * n ，也即是  n平方次
     }
   }
 }
```

这个方法需要执行 ( n2 + n2 + n + n + 1 + 1 +1 ) = 2n² +2n + 3 次运算，时间复杂度为 T(n) = O(n²)

::: tip 提示

由于 时间复杂度 描述的是算法执行时间与数据规模的 `增长变化趋势`，所以 `常量`、`低阶`、`系数` 实际上对这种增长趋势不产生决定性影响，所以在做时间复杂度分析时 `忽略` 这些项。

:::

### 立方阶 O(n³)

O(n³) 就是在 O(n²) 的基础上再嵌套一层循环

### 对数阶 O(logn)

```js
let i = 1;
const n = 6;
while (i < n) {
  i = i * 2;
}
```

观察上述代码，当循环 x 次后，循环退出。也就是说 2 的 x 次方等于 n。那么 x = log2^n，也就是循环 log2^n 次后循环退出，得出时间复杂度为 O(logn)。`二分查找的时间复杂度就是 O(logn)`。

### 线性对数阶 O(nlogn)

```js
let j = 1;
const n = 6;
for (let i = 0; i <= n; i++) {
    while (j < i) {
        j = j * 2;
    }
}
```

理解了对数阶和线性阶，线性对数阶理解起来就很容易了，就是将时间复杂度为 O(logn) 的代码循环 n 遍，那么它的时间复杂度就是 O (nlogn)。`归并排序、快速排序、堆排序的时间复杂度都是 O(nlogn)`。

### 指数阶 O(2^n)

### 阶乘阶 O(n!)

## 空间复杂度度

空间复杂度全称就是 `渐进空间复杂度`（asymptotic space complexity），表示 `算法的存储空间与数据规模之间的增长关系`

算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记作：`S(n) = O(f(n))`，其中，n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数。

```js
function print(n) {
 const newArr = []; // 第 2 行
 newArr.length = n; // 第 3 行
  for (let i = 0; i <n; ++i) {
    newArr[i] = i * i;
  }

  for (let j = n-1; j >= 0; --j) {
    console.log(newArr[i])
  }
}
```

跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 newArr ，是个空数组。第 3 行把 newArr 的长度修改为 n 的长度的数组，每项的值为 undefined ，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。

常见的空间复杂度就是 O(1)、O(n)、O(n²)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到

[参考](https://github.com/biaochenxuying/blog/issues/29)
